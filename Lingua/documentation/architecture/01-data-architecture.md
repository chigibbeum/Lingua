# Data Architecture

## Overview

FLIP uses a real-time, document-based architecture powered by Cloud Firestore with reactive Svelte stores for client-side state management. This architecture enables instant UI updates, offline support, and multi-device synchronization.

## Architecture Pattern

**Smart Store Pattern with Real-Time Sync**

```
Firestore Collection
        │
        ▼
onSnapshot Listener (Real-time)
        │
        ▼
Readable Svelte Store
        │
        ▼
Derived Stores (Computed)
        │
        ▼
UI Components (Reactive)
```

## Firestore Database Schema

### Collections

#### 1. **`flashcards` Collection**

Document structure for each flashcard:

```javascript
{
  // Document ID: Auto-generated by Firestore
  
  // Core Content
  id: string,                      // Firestore document ID
  userId: string,                  // Owner user ID (indexed)
  targetVocabulary: string,        // Word/phrase in target language
  nativeTranslation: string,       // Translation in native language
  tagIds: string[],                // Array of tag document IDs
  
  // Metadata
  createdAt: Timestamp,            // Creation timestamp
  updatedAt: Timestamp,            // Last update timestamp
  
  // Review Tracking (Phase 2)
  lastReviewedAt: Timestamp | null,  // Last study session
  nextReviewAt: Timestamp | null,    // Next scheduled review
  reviewCount: number,               // Total number of reviews
  successCount: number,              // Correct answers
  failCount: number,                 // Incorrect answers
  streak: number,                    // Consecutive correct answers
  
  // Spaced Repetition System (SM-2)
  currentInterval: number,         // Days until next review (default: 1)
  easeFactor: number,              // Difficulty multiplier (default: 2.5)
  masteryLevel: 'new' | 'learning' | 'mastered'
}
```

**Indexes:**
- `userId` (ascending) - For querying user's flashcards
- `userId + createdAt` (compound) - For sorted queries
- `userId + masteryLevel` (compound) - For filtering by mastery
- `userId + nextReviewAt` (compound) - For due date queries

**Example Document:**
```json
{
  "id": "abc123xyz",
  "userId": "user_789",
  "targetVocabulary": "안녕하세요",
  "nativeTranslation": "hello",
  "tagIds": ["tag_001", "tag_002"],
  "createdAt": "2025-09-30T10:00:00Z",
  "updatedAt": "2025-09-30T15:30:00Z",
  "lastReviewedAt": "2025-09-30T15:30:00Z",
  "nextReviewAt": "2025-10-01T15:30:00Z",
  "reviewCount": 3,
  "successCount": 2,
  "failCount": 1,
  "streak": 2,
  "currentInterval": 1,
  "easeFactor": 2.5,
  "masteryLevel": "learning"
}
```

#### 2. **`tags` Collection**

Document structure for organizing flashcards:

```javascript
{
  // Document ID: Auto-generated by Firestore
  
  id: string,                      // Firestore document ID
  userId: string,                  // Owner user ID (indexed)
  name: string,                    // Tag name (e.g., "Food", "Greetings")
  color: string | null,            // Hex color code (e.g., "#90EE90")
  createdAt: Timestamp,            // Creation timestamp
  updatedAt: Timestamp             // Last update timestamp
}
```

**Indexes:**
- `userId` (ascending) - For querying user's tags
- `userId + name` (compound) - For tag name lookups

**Example Document:**
```json
{
  "id": "tag_001",
  "userId": "user_789",
  "name": "Greetings",
  "color": "#90EE90",
  "createdAt": "2025-09-20T10:00:00Z",
  "updatedAt": "2025-09-20T10:00:00Z"
}
```

#### 3. **`users` Collection** (Future)

User profile and settings (not yet implemented):

```javascript
{
  id: string,                      // User ID from Firebase Auth
  displayName: string,
  email: string,
  photoURL: string,
  
  // Preferences
  preferences: {
    defaultNativeLanguage: string,
    defaultTargetLanguage: string,
    studyReminders: boolean,
    dailyGoal: number
  },
  
  // Statistics
  stats: {
    totalFlashcards: number,
    totalReviews: number,
    currentStreak: number,
    longestStreak: number
  },
  
  createdAt: Timestamp,
  lastLoginAt: Timestamp
}
```

## Client-Side Store Architecture

### Store Types

#### 1. **Readable Stores** (Real-Time Sync)

Stores that sync with Firestore in real-time using `onSnapshot` listeners.

**Location**: `/src/lib/stores/`

##### `flashcardsStore.js`

```javascript
// Exports
export const flashcardsStore = readable([], (set) => {
  // Subscribes to user's flashcards collection
  // Updates automatically on any change
})
```

**Behavior:**
- Subscribes to Firebase Auth state changes
- When user logs in: Creates Firestore listener for user's flashcards
- When user logs out: Clears data and tears down listener
- Automatically updates on any Firestore changes (create/update/delete)

**Data Flow:**
```
User Login
    │
    ▼
authStore.userId changes
    │
    ▼
flashcardsStore subscribes to Firestore query:
  collection('flashcards').where('userId', '==', uid)
    │
    ▼
onSnapshot listener fires on every change
    │
    ▼
Store updates with latest data array
    │
    ▼
All subscribed components re-render
```

##### `tagsStore.js`

```javascript
// Exports
export const tagsStore = readable([], (set) => {
  // Subscribes to user's tags collection
})

// Mutation functions
export async function createTag(name, color, userId)
export async function updateTag(tagId, updates)
export async function deleteTag(tagId)
```

**Note:** Tags store includes mutation functions because tags are managed in-line with flashcard editing.

##### `authStore.js`

```javascript
// Exports
export const userStore = writable(null)        // Full user object
export const userId = derived(userStore, ...)  // Just the UID
export const isLoggedIn = derived(userStore, ...) // Boolean

// Authentication functions
export async function loginWithEmailPassword(email, password, rememberMe)
export async function signupWithEmailPassword(email, password, rememberMe)
export async function loginWithProvider(name, rememberMe)
export async function logout()
// ... and more auth methods
```

#### 2. **Derived Stores** (Computed Values)

Stores that compute values based on other stores.

**Example from Lexicon.svelte:**

```javascript
// Computed store that filters and sorts flashcards
const cardsSorted = derived(
  [flashcardsStore, tagsStore, searchQuery],
  ([$cards, $tags, q]) => {
    // Filter by search query
    const filtered = $cards.filter(card => {
      // Search logic
    })
    
    // Sort by createdAt
    return filtered.sort((a, b) => {
      // Sort logic
    })
  }
)
```

**Benefits:**
- Automatically recomputes when dependencies change
- Memoization prevents unnecessary recalculations
- Keeps components simple and focused

#### 3. **Writable Stores** (Local State)

Stores for local UI state that doesn't sync to database.

**Examples:**
- Search queries
- Filter selections
- UI toggle states (view mode, expanded sections)
- Form input values

### Store Subscription Pattern

**In Svelte Components:**

```svelte
<script>
  import { flashcardsStore } from './stores/flashcardsStore.js'
  
  // Auto-subscribe with $ prefix (Svelte magic)
  // Automatically unsubscribes when component unmounts
</script>

<div>
  Total flashcards: {$flashcardsStore.length}
  
  {#each $flashcardsStore as card}
    <!-- Render card -->
  {/each}
</div>
```

**Reactive Updates:**
When Firestore data changes → Store updates → `$flashcardsStore` re-evaluates → Component re-renders

## Database Operations

### CRUD Operations

All database operations are abstracted into helper modules.

#### Flashcard Operations

**Location**: `/src/lib/db/flashcards.js`

```javascript
// Create
export async function createFlashcard(cardData)
  → Returns: document ID

// Read
// (Handled automatically by flashcardsStore via real-time listener)

// Update
export async function updateFlashcard(cardId, updates)
  → Returns: void

// Delete
export async function deleteFlashcard(cardId)
  → Returns: void
```

**Usage Pattern:**

```javascript
import { createFlashcard } from './db/flashcards.js'

// Create new flashcard
const id = await createFlashcard({
  targetVocabulary: '감사합니다',
  nativeTranslation: 'thank you',
  tagIds: ['tag_001']
})

// Firestore triggers onSnapshot
// flashcardsStore automatically updates
// UI automatically re-renders
```

#### Review Operations

**Location**: `/src/lib/db/reviews.js`

```javascript
// Initialize review fields for new flashcards
export function getInitialReviewFields()

// Calculate review statistics after study session
export function calculateReviewUpdate(currentCard, wasCorrect)

// Update flashcard with review data
export async function updateReviewStats(cardId, currentCard, wasCorrect)

// Check if card is due for review
export function isDueForReview(card)

// Get all due cards
export function getDueCards(cards)
```

### Data Flow for User Actions

#### Example: Creating a Flashcard

```
1. User fills form in Create page
   
2. User clicks "Create Flashcard"
   
3. Component calls createFlashcard({...data})
   
4. flashcards.js adds document to Firestore
   
5. Firestore returns document ID
   
6. Function returns to component (optimistic success)
   
7. Firestore triggers onSnapshot listener
   
8. flashcardsStore receives update with new card
   
9. All subscribed components receive new data
   
10. Lexicon page shows new card (if navigated)
```

#### Example: Reviewing a Flashcard

```
1. User flips flashcard on Home page
   
2. User clicks "✓ Correct" button
   
3. Component calls updateReviewStats(cardId, card, true)
   
4. reviews.js calculates new stats using SM-2 algorithm
   
5. Firestore updateDoc() writes new fields
   
6. Firestore triggers onSnapshot listener
   
7. flashcardsStore receives updated card data
   
8. Table view shows updated review count & success rate
```

## Data Synchronization

### Real-Time Sync Flow

```
Device A: Update flashcard
    │
    ▼
Firestore receives update
    │
    ├─→ Triggers onSnapshot on Device A
    │   └─→ flashcardsStore updates
    │       └─→ UI reflects change
    │
    └─→ Triggers onSnapshot on Device B
        └─→ flashcardsStore updates
            └─→ UI reflects change
```

### Offline Behavior

Firestore provides automatic offline persistence:

1. **Writes while offline**: Queued locally, synced when online
2. **Reads while offline**: Served from local cache
3. **Listeners while offline**: Continue to work with cached data
4. **Reconnection**: Automatically syncs queued writes

**User Experience:**
- App remains functional offline
- Changes queue automatically
- Syncs seamlessly when back online
- No manual "sync" button needed

## Query Patterns

### Common Queries

```javascript
// 1. Get all flashcards for current user
query(
  collection(db, 'flashcards'),
  where('userId', '==', currentUserId)
)

// 2. Get flashcards with specific tag
// (Filtered client-side from flashcardsStore)
cards.filter(c => c.tagIds.includes(tagId))

// 3. Get due flashcards
// (Filtered client-side using isDueForReview)
cards.filter(c => isDueForReview(c))

// 4. Get flashcards by mastery level
cards.filter(c => c.masteryLevel === 'new')

// 5. Search flashcards
cards.filter(c => 
  c.targetVocabulary.includes(query) ||
  c.nativeTranslation.includes(query)
)
```

### Performance Optimizations

1. **Client-side filtering**: Most filters applied in-memory after initial query
2. **Single collection listener**: One Firestore listener per collection per user
3. **Derived stores**: Computed values cached and only recalculated on dependency changes
4. **Lazy loading**: Components load data only when mounted

## Data Migration Strategy

### Adding New Fields to Existing Documents

**Example: Adding Review Fields (Phase 2)**

**Approach: Backward-compatible nullable fields**

```javascript
// 1. New documents include all fields
{
  ...existingFields,
  reviewCount: 0,
  successCount: 0,
  // etc.
}

// 2. Existing documents remain unchanged

// 3. UI handles missing fields gracefully
const reviewCount = card.reviewCount ?? 0

// 4. First update adds missing fields
// (No batch migration needed)
```

**Benefits:**
- No downtime
- No batch migration scripts
- Gradual migration as documents are updated
- Backward compatible

## Security Considerations

### Data Access Rules

**Firestore Security Rules** (conceptual):

```javascript
// Flashcards: Users can only access their own cards
match /flashcards/{cardId} {
  allow read, write: if request.auth != null
    && request.resource.data.userId == request.auth.uid
}

// Tags: Users can only access their own tags
match /tags/{tagId} {
  allow read, write: if request.auth != null
    && request.resource.data.userId == request.auth.uid
}
```

### Client-Side Validation

**Input Sanitization:**
- All user input sanitized before saving
- XSS prevention in inline editing
- Type validation for all fields

**Data Integrity:**
- Required fields enforced client-side
- Tag references validated before save
- Date/timestamp validation

## Data Export/Import

### CSV Import

**Location**: `/src/lib/utils/importer.js`

**Format:**
```csv
question,answer,tags
안녕하세요,hello,"Greetings,Basic"
감사합니다,thank you,"Greetings,Politeness"
```

**Process:**
1. Parse CSV into rows
2. Extract unique tag names
3. Query or create tags (get/create IDs)
4. Batch write flashcards with tag references
5. Return summary (created count, errors)

**Features:**
- Auto-creates missing tags with default color
- Batch operations for performance
- Header row detection
- Error recovery

### Future: CSV Export

**Planned features:**
- Export user's flashcards to CSV
- Include review statistics
- Filtered exports (by tag, mastery level, etc.)

## Related Documentation

- [System Overview](./00-system-overview.md)
- [Authentication System](./02-authentication-system.md)
- [Study & Review System](./03-study-review-system.md)

---

**Last Updated**: 2025-09-30  
**Version**: 2.0 (Post-Phase 2 Implementation)
